---
description: 
globs: 
alwaysApply: false
---
# ðŸ“„ Rule: Dynamic Form-Driven UI with File Upload Support

## System Overview

You are building a no-code admin dashboard powered by Supabase. Each form is defined by a row in the `public.forms` table, where a JSON configuration describes how to render and validate input fields. These forms dynamically handle creating and editing records in various tables, such as `articles`, and now include **file upload support** via a separate table: `forms.files`.

---

## âœ… File Upload Field Rule

When a field in the JSON schema has `"type": "file"`, it triggers the system to:

1. Render a file upload UI in the form.
2. Upload the file to Supabase Storage using the specified `bucket` and `storage_path`.
3. Save a record in `forms.files` linking the uploaded file to the parent record (`articles`, etc.).

### Example JSON Field

```json
{
  "acl": "public",
  "name": "header_url",
  "type": "file",
  "label": "Header Image",
  "bucket": "article-assets",
  "validations": ["file", "image"],
  "storage_path": "public/articles/header_images"
}



â¸»

ðŸ“‚ forms.files Table (PostgreSQL SQL Migration)

create schema if not exists forms;

create table if not exists forms.files (
  id bigserial primary key,
  resource_id uuid not null,
  resource_table_name text not null,
  field_name text not null,

  bucket text not null,
  path text not null,
  acl text default 'public',

  filename text not null,
  mime_type text,
  size bigint,

  metadata jsonb,

  created_at timestamp with time zone default now(),
  updated_at timestamp with time zone default now()
);

create index on forms.files (resource_id, resource_table_name);
create index on forms.files (field_name);



â¸»

ðŸ”„ Route Behavior (Next.js Layout)

/forms
	â€¢	List of all available form configurations from public.forms.
	â€¢	Each form row shows:
	â€¢	name
	â€¢	table_name
	â€¢	[Edit Form] button
	â€¢	[View All Records] â†’ /forms/[table_name]/all

â¸»

/forms/[table_name]/all
	â€¢	Fetches and displays all records in the given table.
	â€¢	Uses JSON config from public.forms to:
	â€¢	Determine which columns to show
	â€¢	Display an Edit button per row: /forms/[table_name]/[record_id]/edit

â¸»

/forms/[table_name]/[record_id]/edit
	â€¢	Dynamically renders a form for editing a single record.
	â€¢	Steps:
	1.	Get the form JSON where table_name = [table_name]
	2.	Get the record where id = [record_id]
	3.	Fetch any matching forms.files by resource_id and field_name
	4.	Render inputs for fields (text, select, file, etc.)
	5.	On submit, update both:
	â€¢	The table record
	â€¢	The file list (new uploads go into forms.files, old ones can be marked or deleted)

â¸»

ðŸŽ¯ Future Features
	â€¢	ðŸ†• Form builder for creating/editing form JSON (/forms/new)
	â€¢	âœ… Auto-create buckets if missing
	â€¢	ðŸ–¼ï¸ File previews for image uploads
	â€¢	ðŸ—‘ï¸ Soft delete or version control in forms.files

â¸»

ðŸ’¡ Pro Tip

All file uploads are related to content by:
	â€¢	resource_id â†’ the UUID of the related record
	â€¢	resource_table_name â†’ e.g., articles
	â€¢	field_name â†’ e.g., header_url, images

This allows multiple file fields per resource, all cleanly managed via metadata.



## Display Options

when viewing a page like **forms/FORM_NAME/all**

We might want to hide a field like body since it is too big

```json
{
    "name": "content",
    "type": "textarea",
    "label": "Content",
    "views": [
        {
        "name": "all",
        "display": "none" 
        }
    ],
}
```

so we check views with name "all" and then display none means hide it by default we show all columns


## TextArea and Markdown

if a JSON object is type: textarea we use the markdown editor library here to render and write the content

```
// Install with npm or yarn
// npm install @tiptap/react @tiptap/extension-markdown @tiptap/starter-kit

import { useEditor, EditorContent } from '@tiptap/react'
import StarterKit from '@tiptap/starter-kit'
import Markdown from '@tiptap/extension-markdown'

// Then in your component:
const editor = useEditor({
  extensions: [
    StarterKit,
    Markdown,
  ],
  content: values[field.name], // Your initial content
  onUpdate: ({ editor }) => {
    handleChange(field.name, editor.getHTML())
  },
})

// In your render method:
<EditorContent editor={editor} className="mb-1 px-4 py-2" />
```
