---
description: 
globs: 
alwaysApply: false
---
Perfect â€” youâ€™re laying down a very intuitive and flexible admin interface pattern. Hereâ€™s how to articulate this next AI prompt so it can help scaffold the UI logic, routing, and data handling for form-driven CRUD. Weâ€™ll turn your vision into a clear design + logic prompt that can drive frontend development or even generate code later.

â¸»

ğŸ§­ Prompt to Generate Form-Driven UI Layout and Routing

You are helping build a no-code admin dashboard powered by Supabase. Authentication is already handled. The system uses a table called public.forms, where each row represents a JSON configuration for a form to create or edit data for a given table (e.g., articles). The JSON describes the form layout and field types.

â¸»

ğŸ—‚ï¸ Current Route: /forms
	â€¢	This route shows a list of all forms stored in the forms table.
	â€¢	Each row includes:
	â€¢	name (human-readable)
	â€¢	table_name (e.g., â€œarticlesâ€)
	â€¢	A button or link: Edit Form
	â€¢	A link: View All Records
	â€¢	Goes to /forms/[table_name]/all
	â€¢	A single â€œNew Formâ€ button appears (functionality coming later).

â¸»

NOTE: From here on it is dyanamic routing

Yes â€” what youâ€™re describing is totally possible in Next.js, even with its file-based routing, using dynamic segments and catch-all routes.

Hereâ€™s the key: for /forms/[table_name]/[record_id]/edit, you can use nested dynamic routes, and it works cleanly in Next.js 13/14+ (app router) or pages-based router too.

â¸»

âœ… Next.js Route Strategy (Dynamic Form Editing)

You want this route:

/forms/[table_name]/[record_id]/edit

ğŸ§± Hereâ€™s how to structure this in app/ router (Next.js 13+):

app/
â”œâ”€ forms/
â”‚  â”œâ”€ [table_name]/
â”‚  â”‚  â”œâ”€ [record_id]/
â”‚  â”‚  â”‚  â””â”€ edit/
â”‚  â”‚  â”‚     â””â”€ page.tsx  â† this renders the dynamic form

Then in app/forms/[table_name]/[record_id]/edit/page.tsx:

export default async function EditForm({ params }) {
  const { table_name, record_id } = params;

  // 1. Fetch the JSON form config from `forms` table where table_name = table_name
  // 2. Fetch the record from the `table_name` table using `record_id`
  // 3. Render a form based on JSON + prefilled data
}

âœ… Yes, You Can Do This
	â€¢	Next.js will match all these dynamic segments properly.
	â€¢	Itâ€™s clean, scalable, and allows your JSON-based UI logic to dynamically drive the form rendering.
	â€¢	You just need to query params.table_name and params.record_id.

â¸»

> NOTE fomr here on it is dyanmic routing


/forms/[table_name]/[record_id]/edit
	â€¢	This is a dynamic route that renders a form for editing a single record in the selected table.
	â€¢	It uses:
	â€¢	params.table_name to determine which table to update.
	â€¢	params.record_id to fetch the existing record.
	â€¢	The form schema stored in public.forms (filtered by table_name) to render the fields.

Example:
	â€¢	/forms/articles/1/edit â†’ Edits record 1 in table articles
	â€¢	Uses the JSON schema stored for "articles" in the forms table



ğŸ”„ Route: /forms/[table_name]/all
	â€¢	This page fetches records from the specified table (articles, etc).
	â€¢	It uses the JSON config from the forms table to:
	â€¢	Know which fields to show in the table (e.g., title, published, id)
	â€¢	Each row has an Edit button:
	â€¢	Goes to /forms/[table_name]/[record_id]/edit

â¸»

ğŸ“ Route: /forms/[table_name]/[record_id]/edit
	â€¢	This page renders a dynamic form based on the JSON stored in the forms table (row with table_name = articles).
	â€¢	The form fields (text, checkbox, file, relation, etc) are derived from the fields array in that JSON.
	â€¢	On submit, it updates the underlying table (articles, in this example) with the new data.

â¸»

ğŸ’¾ Data Source
	â€¢	All form metadata comes from the forms table (JSON-driven).
	â€¢	All data being viewed/edited comes from the actual Postgres table referenced by table_name.

â¸»

ğŸ¯ Task

Based on the above:
	â€¢	Generate a component layout and logic tree for this interface.
	â€¢	Define the routing structure clearly.
	â€¢	Provide notes for what data each page needs to load (e.g., useEffect for fetching JSON + data).
	â€¢	Keep the interface simple and minimal (Next.js, Tailwind, or your choice).
	â€¢	Future-proof this so itâ€™s easy to add the â€œNew Formâ€ builder step later.

â¸»

Would you like me to return:
	â€¢	A React route map + layout tree
	â€¢	Or Next.js file structure + pseudocode for the pages
	â€¢	Or the actual React code for one of the routes?

Let me know which direction youâ€™d like to go first â€” /forms, /forms/articles/all, or /forms/articles/[id]/edit.